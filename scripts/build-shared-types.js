#!/usr/bin/env node

/**
 * Centralized shared types build utility
 * Optimized for monorepo with smart caching and dependency management
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// Paths
const ROOT_DIR = path.join(__dirname, '..');
const SHARED_DIR = path.join(ROOT_DIR, 'shared');
const SHARED_SRC_DIR = path.join(SHARED_DIR, 'src');
const SHARED_DIST_DIR = path.join(SHARED_DIR, 'dist');

// Package configurations
const PACKAGES = {
  functions: {
    dir: path.join(ROOT_DIR, 'functions'),
    srcTarget: path.join(ROOT_DIR, 'functions/src/shared-generated'),
    libTarget: path.join(ROOT_DIR, 'functions/lib/shared-generated'),
    needsLibCopy: true, // Firebase Functions needs both src and lib copies
  },
  web: {
    dir: path.join(ROOT_DIR, 'web'),
    srcTarget: path.join(ROOT_DIR, 'web/src/shared-generated'),
    libTarget: null, // Web doesn't need lib copy (handled by bundler)
    needsLibCopy: false,
  }
};

/**
 * Get file modification time for cache checking
 */
function getLastModified(dirPath) {
  if (!fs.existsSync(dirPath)) return 0;
  
  let latestTime = 0;
  
  function checkDir(currentDir) {
    const entries = fs.readdirSync(currentDir, { withFileTypes: true });
    
    for (const entry of entries) {
      const fullPath = path.join(currentDir, entry.name);
      
      if (entry.isDirectory()) {
        checkDir(fullPath);
      } else {
        const stat = fs.statSync(fullPath);
        latestTime = Math.max(latestTime, stat.mtime.getTime());
      }
    }
  }
  
  checkDir(dirPath);
  return latestTime;
}

/**
 * Check if shared types need to be rebuilt
 */
function needsRebuild() {
  const srcModified = getLastModified(SHARED_SRC_DIR);
  const distModified = getLastModified(SHARED_DIST_DIR);
  
  // If dist doesn't exist or src is newer than dist, rebuild needed
  return !fs.existsSync(SHARED_DIST_DIR) || srcModified > distModified;
}

/**
 * Build shared types package
 */
function buildSharedTypes() {
  if (!needsRebuild()) {
    console.log('📦 Shared types are up to date, skipping build');
    return false;
  }
  
  console.log('🔨 Building shared types...');
  
  try {
    // Use pnpm to build shared package
    execSync('pnpm shared:build', { 
      cwd: ROOT_DIR, 
      stdio: 'inherit' 
    });
    
    console.log('✅ Shared types built successfully');
    return true;
  } catch (error) {
    console.error('❌ Failed to build shared types:', error.message);
    process.exit(1);
  }
}

/**
 * Recursively copy directory contents
 */
function copyDirectory(src, dest) {
  if (!fs.existsSync(src)) {
    console.error(`❌ Source directory does not exist: ${src}`);
    return false;
  }

  // Create destination directory if it doesn't exist
  if (!fs.existsSync(dest)) {
    fs.mkdirSync(dest, { recursive: true });
  }

  const entries = fs.readdirSync(src, { withFileTypes: true });

  for (const entry of entries) {
    const srcPath = path.join(src, entry.name);
    const destPath = path.join(dest, entry.name);

    if (entry.isDirectory()) {
      copyDirectory(srcPath, destPath);
    } else {
      fs.copyFileSync(srcPath, destPath);
    }
  }
  
  return true;
}

/**
 * Generate package-specific helper files
 */
function generateHelperFiles(packageName, targetDir) {
  // Generate shared.js for easy importing
  const sharedJsContent = `/**
 * Generated shared types entry point for ${packageName}
 * 
 * This file is automatically generated by scripts/build-shared-types.js
 * DO NOT EDIT MANUALLY - changes will be overwritten
 */

module.exports = require('./index');
`;

  // Generate shared.d.ts for TypeScript
  const sharedDtsContent = `/**
 * Generated TypeScript declarations for ${packageName}
 * 
 * This file is automatically generated by scripts/build-shared-types.js
 * DO NOT EDIT MANUALLY - changes will be overwritten
 */

export * from './index';

// Convenience re-exports
export type {
  IOperationResult,
  User,
  Product,
  Order,
  OrderItem,
  Address,
  ApiResponse,
} from './index';

export {
  UserRole,
  OrderStatus,
  PaymentStatus,
  ProductCategory,
  NotificationType,
  OperationStatus,
} from './index';
`;

  fs.writeFileSync(path.join(targetDir, 'shared.js'), sharedJsContent);
  fs.writeFileSync(path.join(targetDir, 'shared.d.ts'), sharedDtsContent);
}

/**
 * Copy shared types to a specific package
 */
function copyToPackage(packageName, config) {
  if (!fs.existsSync(config.dir)) {
    console.log(`⚠️  Package ${packageName} directory not found, skipping`);
    return false;
  }

  console.log(`📂 Copying shared types to ${packageName}...`);

  // Clean old files
  if (fs.existsSync(config.srcTarget)) {
    fs.rmSync(config.srcTarget, { recursive: true, force: true });
  }
  if (config.libTarget && fs.existsSync(config.libTarget)) {
    fs.rmSync(config.libTarget, { recursive: true, force: true });
  }

  // Copy to src directory
  if (copyDirectory(SHARED_DIST_DIR, config.srcTarget)) {
    generateHelperFiles(packageName, config.srcTarget);
    
    // Copy to lib directory if needed (for Firebase Functions)
    if (config.needsLibCopy && config.libTarget) {
      copyDirectory(config.srcTarget, config.libTarget);
    }
    
    console.log(`✅ Shared types copied to ${packageName}`);
    return true;
  }
  
  return false;
}

/**
 * Main execution
 */
function main() {
  const args = process.argv.slice(2);
  const targetPackages = args.length > 0 ? args : Object.keys(PACKAGES);
  
  console.log('🚀 Optimized shared types build starting...');
  console.log(`📋 Target packages: ${targetPackages.join(', ')}`);
  
  // Step 1: Build shared types (only if needed)
  const wasRebuilt = buildSharedTypes();
  
  // Step 2: Copy to target packages
  let successCount = 0;
  for (const packageName of targetPackages) {
    const config = PACKAGES[packageName];
    if (!config) {
      console.warn(`⚠️  Unknown package: ${packageName}`);
      continue;
    }
    
    if (copyToPackage(packageName, config)) {
      successCount++;
    }
  }
  
  console.log(`\n🎉 Build completed successfully!`);
  console.log(`   📦 Shared types ${wasRebuilt ? 'rebuilt' : 'up to date'}`);
  console.log(`   📂 Copied to ${successCount}/${targetPackages.length} packages`);
}

// Export for programmatic use
module.exports = {
  buildSharedTypes,
  copyToPackage,
  needsRebuild,
  PACKAGES,
  main
};

// Run if called directly
if (require.main === module) {
  main();
}
